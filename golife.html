<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conway's Game of Life</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2980, #b416e8);
            color: #fff;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            width: 100%;
            max-width: 1400px;
            background-color: rgba(15, 25, 60, 0.7);
            border-radius: 20px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }
        
        header {
            text-align: center;
            padding: 25px;
            background: linear-gradient(to right, #2c3e50, #4a6491);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            background: linear-gradient(to right, #f7b731, #ff6a00);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            letter-spacing: 1px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 700px;
            margin: 0 auto;
        }
        
        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            padding: 25px;
        }
        
        .simulation-container {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        canvas {
            background-color: #0a192f;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
            cursor: pointer;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 600px;
            margin-top: 20px;
            margin-bottom: 30px;
        }
        
        button {
            padding: 12px 25px;
            background: linear-gradient(to right, #4a90e2, #5c6bc0);
            color: white;
            border: none;
            border-radius: 30px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(74, 144, 226, 0.4);
            background: linear-gradient(to right, #5c6bc0, #4a90e2);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .reset-btn {
            background: linear-gradient(to right, #ff6b6b, #ff8e8e);
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 600px;
            margin-bottom: 20px;
        }
        
        .control-group {
            background-color: rgba(30, 47, 86, 0.7);
            border-radius: 15px;
            padding: 20px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }
        
        .control-group h3 {
            margin-bottom: 15px;
            font-size: 1.3rem;
            color: #f7b731;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            opacity: 0.9;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #33476e;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #4a90e2;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(74, 144, 226, 0.8);
        }
        
        input[type="range"]:hover::-webkit-slider-thumb {
            background: #5c6bc0;
        }
        
        .value-display {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            margin-top: 10px;
            color: #4ade80;
        }
        
        .info-panel {
            flex: 0 0 350px;
            background-color: rgba(30, 47, 86, 0.7);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }
        
        .info-panel h2 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #f7b731;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .info-panel ul {
            padding-left: 20px;
        }
        
        .info-panel li {
            margin-bottom: 15px;
            line-height: 1.6;
        }
        
        .rule {
            font-weight: bold;
            color: #4ade80;
        }
        
        .stats-container {
            background-color: rgba(30, 47, 86, 0.7);
            border-radius: 20px;
            padding: 25px;
            margin-top: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }
        
        .stats-container h2 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #f7b731;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .stat-item {
            background-color: rgba(47, 79, 135, 0.6);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            transition: transform 0.3s ease;
        }
        
        .stat-item:hover {
            transform: translateY(-5px);
            background-color: rgba(64, 98, 147, 0.7);
        }
        
        .stat-label {
            font-size: 1rem;
            opacity: 0.8;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4ade80;
        }
        
        @media (max-width: 900px) {
            .content {
                flex-direction: column;
            }
            
            .info-panel {
                flex: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-square"></i> Conway's Game of Life</h1>
            <p class="subtitle">A cellular automaton simulation where simple rules create complex patterns. Customize grid dimensions, cell size, and update speed to explore different behaviors.</p>
        </header>
        
        <div class="content">
            <div class="simulation-container">
                <canvas id="gameCanvas"></canvas>
                
                <div class="controls">
                    <button id="startBtn"><i class="fas fa-play"></i> Start</button>
                    <button id="pauseBtn" disabled><i class="fas fa-pause"></i> Pause</button>
                    <button id="stepBtn"><i class="fas fa-step-forward"></i> Step</button>
                    <button id="randomBtn"><i class="fas fa-dice"></i> Random Start</button>
                    <button id="resetBtn" class="reset-btn"><i class="fas fa-redo"></i> Reset Grid</button>
                </div>

                <div class="controls" style="margin-top: 10px;">
                    <select id="patternSelect" style="padding: 12px 20px; background: linear-gradient(to right, #4a90e2, #5c6bc0); color: white; border: none; border-radius: 30px; font-size: 1rem; cursor: pointer;">
                        <option value="">Select a Pattern</option>
                        <option value="glider">Glider</option>
                        <option value="lwss">Lightweight Spaceship</option>
                        <option value="pulsar">Pulsar</option>
                        <option value="gosperGliderGun">Gosper Glider Gun</option>
                        <option value="blinker">Blinker</option>
                        <option value="toad">Toad</option>
                        <option value="beacon">Beacon</option>
                        <option value="pentadecathlon">Pentadecathlon</option>
                        <option value="block">Block</option>
                        <option value="beehive">Beehive</option>
                    </select>
                    <button id="placePatternBtn"><i class="fas fa-plus-circle"></i> Place Pattern</button>
                </div>

                <div class="controls" style="margin-top: 10px;">
                    <button id="saveBtn" style="background: linear-gradient(to right, #10b981, #059669);"><i class="fas fa-save"></i> Save Pattern</button>
                    <button id="loadBtn" style="background: linear-gradient(to right, #f59e0b, #d97706);"><i class="fas fa-upload"></i> Load Pattern</button>
                    <input type="file" id="fileInput" accept=".json" style="display: none;">
                </div>
                
                <div class="controls-grid">
                    <div class="control-group">
                        <h3><i class="fas fa-expand-alt"></i> Grid Dimensions</h3>
                        <label for="rows">Rows: <span id="rowsValue">50</span></label>
                        <input type="range" id="rows" min="20" max="100" value="50">
                        
                        <label for="cols">Columns: <span id="colsValue">80</span></label>
                        <input type="range" id="cols" min="20" max="100" value="80">
                    </div>
                    
                    <div class="control-group">
                        <h3><i class="fas fa-sync-alt"></i> Cell Size</h3>
                        <label for="cellSize">Cell Size: <span id="cellSizeValue">6</span></label>
                        <input type="range" id="cellSize" min="2" max="15" value="6">
                    </div>
                    
                    <div class="control-group">
                        <h3><i class="fas fa-tachometer-alt"></i> Update Speed</h3>
                        <label for="speed">Speed: <span id="speedValue">Normal</span></label>
                        <input type="range" id="speed" min="1" max="5" value="3">
                    </div>

                    <div class="control-group">
                        <h3><i class="fas fa-border-all"></i> Edge Behavior</h3>
                        <label for="boundaryMode">
                            <input type="checkbox" id="boundaryMode" checked style="margin-right: 8px;">
                            Toroidal (Wrap Around)
                        </label>
                        <div style="margin-top: 8px; font-size: 0.85rem; opacity: 0.8;">
                            When unchecked, edges are fixed (cells outside grid are dead)
                        </div>
                    </div>

                    <div class="control-group">
                        <h3><i class="fas fa-palette"></i> Cell Colors</h3>
                        <label for="colorByAge">
                            <input type="checkbox" id="colorByAge" style="margin-right: 8px;">
                            Color by Cell Age
                        </label>
                        <div style="margin-top: 8px; font-size: 0.85rem; opacity: 0.8;">
                            Shows gradient: young (cyan) → mature (blue) → old (purple)
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="info-panel">
                <h2><i class="fas fa-info-circle"></i> Game of Life Overview</h2>
                <p>The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.</p>
                
                <div class="rule">
                    Each cell interacts with its eight neighbors (cells that are horizontally, vertically, or diagonally adjacent). At each step in time,
                    the following transitions occur:
                </div>
                
                <ul>
                    <li><span class="rule">Survival:</span> A live cell with 2 or 3 live neighbors survives.</li>
                    <li><span class="rule">Death:</span> A live cell with fewer than two live neighbors dies (underpopulation).</li>
                    <li><span class="rule">Death:</span> A live cell with more than three live neighbors dies (overpopulation).</li>
                    <li><span class="rule">Birth:</span> A dead cell with exactly three live neighbors becomes a live cell.</li>
                </ul>
                
                <p>This deceptively simple set of rules gives rise to complex and interesting patterns, including oscillators, spaceships, and still lifes.</p>
            </div>
        </div>
        
        <div class="stats-container">
            <h2><i class="fas fa-chart-line"></i> Simulation Statistics</h2>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">Generation:</div>
                    <div class="stat-value" id="generationCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Live Cells:</div>
                    <div class="stat-value" id="liveCellsCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Grid Size:</div>
                    <div class="stat-value" id="gridSize">50x80</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Update Frequency:</div>
                    <div class="stat-value" id="updateFrequency">Normal</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Famous Conway's Game of Life patterns
        const patterns = {
            glider: [[0,1], [1,2], [2,0], [2,1], [2,2]],
            lwss: [[0,1], [0,4], [1,0], [2,0], [3,0], [3,4], [4,0], [4,1], [4,2], [4,3]],
            pulsar: [
                [2,4], [2,5], [2,6], [2,10], [2,11], [2,12],
                [4,2], [4,7], [4,9], [4,14],
                [5,2], [5,7], [5,9], [5,14],
                [6,2], [6,7], [6,9], [6,14],
                [7,4], [7,5], [7,6], [7,10], [7,11], [7,12],
                [9,4], [9,5], [9,6], [9,10], [9,11], [9,12],
                [10,2], [10,7], [10,9], [10,14],
                [11,2], [11,7], [11,9], [11,14],
                [12,2], [12,7], [12,9], [12,14],
                [14,4], [14,5], [14,6], [14,10], [14,11], [14,12]
            ],
            gosperGliderGun: [
                [5,1], [5,2], [6,1], [6,2],
                [5,11], [6,11], [7,11], [4,12], [8,12], [3,13], [9,13], [3,14], [9,14],
                [6,15], [4,16], [8,16], [5,17], [6,17], [7,17], [6,18],
                [3,21], [4,21], [5,21], [3,22], [4,22], [5,22], [2,23], [6,23],
                [1,25], [2,25], [6,25], [7,25],
                [3,35], [4,35], [3,36], [4,36]
            ],
            blinker: [[0,0], [0,1], [0,2]],
            toad: [[1,1], [1,2], [1,3], [2,0], [2,1], [2,2]],
            beacon: [[0,0], [0,1], [1,0], [2,3], [3,2], [3,3]],
            pentadecathlon: [
                [0,2], [1,2], [2,1], [2,3], [3,2], [4,2], [5,2], [6,2], [7,1], [7,3], [8,2], [9,2]
            ],
            block: [[0,0], [0,1], [1,0], [1,1]],
            beehive: [[0,1], [0,2], [1,0], [1,3], [2,1], [2,2]]
        };

        // Get references to DOM elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Control buttons
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stepBtn = document.getElementById('stepBtn');
        const randomBtn = document.getElementById('randomBtn');
        const resetBtn = document.getElementById('resetBtn');
        const patternSelect = document.getElementById('patternSelect');
        const placePatternBtn = document.getElementById('placePatternBtn');
        const saveBtn = document.getElementById('saveBtn');
        const loadBtn = document.getElementById('loadBtn');
        const fileInput = document.getElementById('fileInput');
        
        // Controls for parameters
        const rowsSlider = document.getElementById('rows');
        const colsSlider = document.getElementById('cols');
        const cellSizeSlider = document.getElementById('cellSize');
        const speedSlider = document.getElementById('speed');
        const boundaryModeCheckbox = document.getElementById('boundaryMode');
        const colorByAgeCheckbox = document.getElementById('colorByAge');
        
        // Value displays
        const rowsValue = document.getElementById('rowsValue');
        const colsValue = document.getElementById('colsValue');
        const cellSizeValue = document.getElementById('cellSizeValue');
        const speedValue = document.getElementById('speedValue');
        
        // Stats display elements
        const generationCount = document.getElementById('generationCount');
        const liveCellsCount = document.getElementById('liveCellsCount');
        const gridSize = document.getElementById('gridSize');
        const updateFrequency = document.getElementById('updateFrequency');
        
        // Simulation parameters
        let config = {
            rows: 50,
            cols: 80,
            cellSize: 6,
            speed: 3, // 1-5 (1 is fastest)
            scale: 1.2,
            toroidalEdges: true, // true = wrap-around, false = fixed edges
            colorByAge: false // true = color cells based on age
        };

        // Game state variables
        let grid = [];
        let nextGrid = [];
        let cellAges = []; // Track how many generations each cell has been alive
        let nextCellAges = [];
        let animationId;
        let isRunning = false;
        let generation = 0;
        let lastUpdateTime = 0;
        const updateInterval = [0, 50, 80, 120, 160, 200]; // ms between updates (index: speed level)
        
        // Initialize the simulation
        function initSimulation() {
            // Set canvas dimensions based on configuration
            resizeCanvas();

            // Create new grids
            grid = createEmptyGrid(config.rows, config.cols);
            nextGrid = [...grid].map(row => [...row]);
            cellAges = createEmptyGrid(config.rows, config.cols);
            nextCellAges = createEmptyGrid(config.rows, config.cols);

            // Reset statistics
            generation = 0;
            updateStats();

            // Draw initial state
            drawGrid();
        }
        
        // Resize canvas when parameters change
        function resizeCanvas() {
            const width = Math.min(config.cols * config.cellSize, window.innerWidth - 100);
            const height = Math.min(config.rows * config.cellSize, window.innerHeight - 250);
            
            canvas.width = width;
            canvas.height = height;
        }
        
        // Create an empty grid
        function createEmptyGrid(rows, cols) {
            return Array.from({ length: rows }, () => 
                Array(cols).fill(0)
            );
        }
        
        // Generate a random initial state
        function randomizeGrid() {
            for (let i = 0; i < config.rows; i++) {
                for (let j = 0; j < config.cols; j++) {
                    grid[i][j] = Math.random() > 0.7 ? 1 : 0;
                }
            }

            updateStats();
        }

        // Place a preset pattern on the grid
        function placePattern(patternName) {
            if (!patterns[patternName]) {
                alert('Please select a pattern first!');
                return;
            }

            const pattern = patterns[patternName];

            // Calculate center position for the pattern
            const patternHeight = Math.max(...pattern.map(p => p[0])) + 1;
            const patternWidth = Math.max(...pattern.map(p => p[1])) + 1;
            const startRow = Math.floor((config.rows - patternHeight) / 2);
            const startCol = Math.floor((config.cols - patternWidth) / 2);

            // Place the pattern
            pattern.forEach(([row, col]) => {
                const r = startRow + row;
                const c = startCol + col;
                if (r >= 0 && r < config.rows && c >= 0 && c < config.cols) {
                    grid[r][c] = 1;
                }
            });

            updateStats();
            drawGrid();
        }

        // Save current grid state to JSON file
        function savePattern() {
            const pattern = {
                name: 'custom-pattern',
                timestamp: new Date().toISOString(),
                rows: config.rows,
                cols: config.cols,
                grid: grid,
                generation: generation
            };

            const dataStr = JSON.stringify(pattern, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });

            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `game-of-life-${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(link.href);
        }

        // Load pattern from JSON file
        function loadPattern(file) {
            const reader = new FileReader();

            reader.onload = (e) => {
                try {
                    const pattern = JSON.parse(e.target.result);

                    // Validate the pattern
                    if (!pattern.grid || !Array.isArray(pattern.grid)) {
                        alert('Invalid pattern file format!');
                        return;
                    }

                    // Update config if dimensions differ
                    if (pattern.rows && pattern.cols) {
                        config.rows = pattern.rows;
                        config.cols = pattern.cols;
                        rowsSlider.value = config.rows;
                        colsSlider.value = config.cols;
                        rowsValue.textContent = config.rows;
                        colsValue.textContent = config.cols;
                    }

                    // Load the grid
                    resizeCanvas();
                    grid = pattern.grid.map(row => [...row]);
                    nextGrid = grid.map(row => [...row]);
                    cellAges = createEmptyGrid(config.rows, config.cols);
                    nextCellAges = createEmptyGrid(config.rows, config.cols);

                    // Reset generation or use saved value
                    generation = pattern.generation || 0;

                    updateStats();
                    drawGrid();

                    alert('Pattern loaded successfully!');
                } catch (error) {
                    alert('Error loading pattern: ' + error.message);
                }
            };

            reader.readAsText(file);
        }
        
        // Get color based on cell age
        function getCellColor(age) {
            if (!config.colorByAge || age === 0) {
                return { fill: 'rgba(74, 144, 226, 0.8)', stroke: '#5c6bc0', shadow: '#5c6bc0' };
            }

            // Color gradient: young (cyan) → mature (blue) → old (purple)
            // Age ranges: 1-5 (cyan), 6-15 (blue), 16+ (purple)
            if (age <= 5) {
                // Young cells: cyan
                return { fill: 'rgba(34, 211, 238, 0.8)', stroke: '#22d3ee', shadow: '#22d3ee' };
            } else if (age <= 15) {
                // Mature cells: blue
                return { fill: 'rgba(74, 144, 226, 0.8)', stroke: '#5c6bc0', shadow: '#5c6bc0' };
            } else {
                // Old/stable cells: purple
                return { fill: 'rgba(168, 85, 247, 0.8)', stroke: '#a855f7', shadow: '#a855f7' };
            }
        }

        // Draw the current state of the grid
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < config.rows; i++) {
                for (let j = 0; j < config.cols; j++) {
                    if (grid[i][j]) {
                        const colors = getCellColor(cellAges[i][j]);

                        // Draw filled cell
                        ctx.fillStyle = colors.fill;
                        ctx.fillRect(j * config.cellSize, i * config.cellSize, config.cellSize, config.cellSize);

                        // Add glow effect
                        ctx.shadowColor = colors.shadow;
                        ctx.shadowBlur = 15;
                        ctx.beginPath();
                        ctx.rect(j * config.cellSize + 2, i * config.cellSize + 2, config.cellSize - 4, config.cellSize - 4);
                        ctx.fillStyle = colors.fill;
                        ctx.fill();
                        ctx.shadowBlur = 0;

                        // Draw cell outline
                        ctx.strokeStyle = colors.stroke;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(j * config.cellSize + 1, i * config.cellSize + 1, config.cellSize - 2, config.cellSize - 2);
                    }
                }
            }
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(74, 144, 226, 0.3)';
            ctx.lineWidth = 0.5;
            
            for (let i = 0; i <= config.rows; i++) {
                const y = i * config.cellSize;
                if (y < canvas.height) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }
            
            for (let j = 0; j <= config.cols; j++) {
                const x = j * config.cellSize;
                if (x < canvas.width) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
            }
        }
        
        // Update the grid state based on Game of Life rules
        function updateGrid() {
            for (let i = 0; i < config.rows; i++) {
                for (let j = 0; j < config.cols; j++) {
                    const liveNeighbors = countLiveNeighbors(i, j);

                    // Apply the rules
                    if (grid[i][j]) {
                        // Cell is alive
                        const willSurvive = (liveNeighbors === 2 || liveNeighbors === 3);
                        nextGrid[i][j] = willSurvive ? 1 : 0;
                        nextCellAges[i][j] = willSurvive ? cellAges[i][j] + 1 : 0;
                    } else {
                        // Cell is dead
                        const willBeBorn = (liveNeighbors === 3);
                        nextGrid[i][j] = willBeBorn ? 1 : 0;
                        nextCellAges[i][j] = willBeBorn ? 1 : 0;
                    }
                }
            }

            // Swap grids
            [grid, nextGrid] = [nextGrid, grid];
            [cellAges, nextCellAges] = [nextCellAges, cellAges];

            // Update statistics
            generation++;
            updateStats();
        }
        
        // Count live neighbors for a cell at (row, col)
        function countLiveNeighbors(row, col) {
            let count = 0;

            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue; // Skip the cell itself

                    let r = row + i;
                    let c = col + j;

                    if (config.toroidalEdges) {
                        // Wrap around edges (toroidal)
                        r = (r + config.rows) % config.rows;
                        c = (c + config.cols) % config.cols;
                        count += grid[r][c];
                    } else {
                        // Fixed edges - cells outside grid are dead
                        if (r >= 0 && r < config.rows && c >= 0 && c < config.cols) {
                            count += grid[r][c];
                        }
                    }
                }
            }

            return count;
        }
        
        // Main animation loop
        function animate(timestamp) {
            if (!isRunning) return;
            
            // Calculate time elapsed since last update
            const deltaTime = timestamp - lastUpdateTime;
            
            // If enough time has passed according to the current speed setting, update grid
            if (deltaTime >= updateInterval[config.speed]) {
                updateGrid();
                drawGrid();
                
                lastUpdateTime = timestamp;
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Update statistics display
        function updateStats() {
            generationCount.textContent = generation.toLocaleString();
            
            let liveCells = 0;
            for (let i = 0; i < config.rows; i++) {
                for (let j = 0; j < config.cols; j++) {
                    liveCells += grid[i][j];
                }
            }
            
            liveCellsCount.textContent = liveCells.toLocaleString();
            gridSize.textContent = `${config.rows}x${config.cols}`;
            
            const speedLabels = ['Fastest', 'Very Fast', 'Normal', 'Slow', 'Slower'];
            updateFrequency.textContent = speedLabels[config.speed - 1];
        }
        
        // Handle canvas click
        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const col = Math.floor(x / config.cellSize);
            const row = Math.floor(y / config.cellSize);
            
            if (row >= 0 && row < config.rows && col >= 0 && col < config.cols) {
                if (!isRunning) {
                    // When paused: toggle cell state
                    grid[row][col] = grid[row][col] ? 0 : 1;
                    drawGrid();
                    
                    // Update stats immediately after manual change
                    generation++;
                    updateStats();
                } else {
                    // When running: only add cells to empty positions
                    if (grid[row][col] === 0) {
                        grid[row][col] = 1;
                        drawGrid();
                        updateStats();
                    }
                }
            }
        }
        
        // Event listeners for controls
        startBtn.addEventListener('click', () => {
            isRunning = true;
            pauseBtn.disabled = false;
            startBtn.disabled = true;
            
            if (!animationId) {
                lastUpdateTime = performance.now();
                animationId = requestAnimationFrame(animate);
            }
        });
        
        pauseBtn.addEventListener('click', () => {
            isRunning = false;
            startBtn.disabled = false;
            pauseBtn.disabled = true;

            cancelAnimationFrame(animationId);
            animationId = null;
        });

        stepBtn.addEventListener('click', () => {
            // Ensure simulation is paused
            if (isRunning) {
                isRunning = false;
                startBtn.disabled = false;
                pauseBtn.disabled = true;
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            // Advance one generation
            updateGrid();
            drawGrid();
        });

        randomBtn.addEventListener('click', () => {
            // Stop any running animation and reset controls
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            isRunning = false;
            startBtn.disabled = false;
            pauseBtn.disabled = true;

            // Generate random pattern
            randomizeGrid();
            drawGrid();
        });

        placePatternBtn.addEventListener('click', () => {
            const selectedPattern = patternSelect.value;
            if (selectedPattern) {
                placePattern(selectedPattern);
            }
        });

        saveBtn.addEventListener('click', () => {
            savePattern();
        });

        loadBtn.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loadPattern(file);
            }
            // Reset file input so the same file can be loaded again
            fileInput.value = '';
        });

        resetBtn.addEventListener('click', () => {
            // Stop any running animation and reset controls
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            isRunning = false;
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            
            initSimulation();
        });
        
        // Event listeners for parameter sliders
        rowsSlider.addEventListener('input', (e) => {
            config.rows = parseInt(e.target.value);
            rowsValue.textContent = config.rows;
            resizeCanvas();
            initSimulation();
        });
        
        colsSlider.addEventListener('input', (e) => {
            config.cols = parseInt(e.target.value);
            colsValue.textContent = config.cols;
            resizeCanvas();
            initSimulation();
        });
        
        cellSizeSlider.addEventListener('input', (e) => {
            config.cellSize = parseInt(e.target.value);
            cellSizeValue.textContent = config.cellSize;
            resizeCanvas();
            drawGrid();
        });
        
        speedSlider.addEventListener('input', (e) => {
            config.speed = parseInt(e.target.value);

            // Update UI with human-readable label
            const labels = ['Fastest', 'Very Fast', 'Normal', 'Slow', 'Slower'];
            speedValue.textContent = labels[config.speed - 1];
        });

        boundaryModeCheckbox.addEventListener('change', (e) => {
            config.toroidalEdges = e.target.checked;
        });

        colorByAgeCheckbox.addEventListener('change', (e) => {
            config.colorByAge = e.target.checked;
            drawGrid(); // Redraw with new color scheme
        });

        // Initialize the simulation when the page loads
        window.addEventListener('load', initSimulation);
        
        // Add click event to canvas
        canvas.addEventListener('click', handleCanvasClick);
    </script>
</body>
</html>
